<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <script>
    /* 'use strict'    //启动严格模式
    function Person(name, age) {   //constructor构造函数
      // new运行的过程，new的时候，this指向实例
      this.name = name;
      console.log(arguments);   //arguments收集所有传过来的参数
    }
    Person.prototype.sing = function() {    // prototype用于为constructor构造函数添加方法
      console.log('遥远的她，来自' + this.name);  // 当一个方法被对象.方法调用的时候，this在方法内部指向对象
    }
    var woniu = new Person('蜗牛', 16);
    woniu.sing(); */


/* ----------------------------------------------------------------------------------------------------------- */
    //动物 -> 人类  //继承
    //人类 -> 蜗牛  //实例化
    /* function Animal(planet) {
      this.planet = planet;
    }
    Animal.prototype.getPlanet = function() {
      return this.planet
    }

    function Person (name) {
      this.name = name;
    }
    //prototype是一个对象，可以把任何对象都给他
    //一个元素想要父对象，让它的prototype对于父对象就可以了
    Person.prototype = new Animal('earth');   //原型链 构造函数的原型对象是Animal的一个实例，即一个对象
    Person.prototype.getName = function () {  //还可以享有Person自己的属性
      console.log(this.name);
    }
    var woniu = new Person('蜗牛');
    woniu.getPlanet();  //继承父类的方法；在Person里找到属性name之后不会停止，继续找Person的原型链，找到Animal
                        //如果找到的是原型链，继续查找下一个原型链，知道找到对象object */


/* ----------------------------------------------------------------------------------------------------------- */
    // js中没有类，Function + prototype 基于原型的面向对象
    var Person = {  //Person是一个对象，function也是对象所以可以这样写；提供一个模板
      name: "noname",
      age: 0,
      greet: function() {
        console.log(`Hello, ${this.name}`);
      }
    }
    //es6 create方法
    var tom = Object.create(Person);  //把对象模板传进去
    console.log(tom);
    tom.name = 'tom';
    tom.age = 24;
    tom.greet();
  </script>
</body>
</html>